@[TOC](第四章 响应系统的作用与实现)
### 1. 响应式数据与副作用函数
副作用函数：会直接或间接影响其他函数执行的函数。例如，一个函数修改了全局变量。
响应式数据：当值变化后，副作用函数自动重新执行。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/548fee6b1fbe40d1a6804562ac6a3bdb.png#pic_center =700x)
<center>图4-1 用于声明变量的关键字区别</center>
假设在一个副作用函数中读取了某个对象的属性：

```javascript
	const obj = ｛ text： 'hello world'｝
	function effect() {
		// effect 函数的执行会读取 obj.text
		document. body.innerText = obj.text
	｝
```
如上面的代码所示，副作用函数 effect 会设置 body 元素的 innerText 属性，其值为obj.text，当obj.text 的值发生变化时，我们希望副作用函数 effect 会重新执行：
```javascript
	obj.text ='hello vue3' //修改 obj.text 的值，同时希望副作用函数会重新执行
```
这句代码修改了字段 obj.text 的值，我们希望当值变化后，副作用函数自动重新执行，如果能实现这个目标，那么对象 obj就是响应式数据。
### 2. 响应式数据的基本实现
接上文思考：

> 当副作用函数 effect 执行时，会触发字段obj.text 的读取操作； 
> 当修改 obj.text 的值时，会触发字段obj.text的设置操作。

我们通过拦截一个对象的读取和设置操作，把副作用函数 effect 存储到一个“桶”里。如图4-2所示。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/11aba1e4f6a84a458e4dc44d50649323.jpeg#pic_center =x200)
<center>图4-2 将副作用函数存储到"桶"中</center>
接着，当设置obj.text 时，再把副作用函数 effect 从“桶”里取出并执行即可，如图4-3所示。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ccc7a5f0e12145b8a88453e537313679.jpeg#pic_center =300x)
<center>图4-3 把副作用函数从"桶"中取出并执行</center>

### 3. 设计一个完善的相应系统
一个响应系统的工作流程如下：

> 当读取操作发生时，将副作用函数收集到“桶”中；
> 当设置操作发生时，从“桶”中取出副作用函数并执行。
> 
为了保证副函数能够被正确地收集到“桶”中，我们需要提供一个用来注册副作用函数的机制，如以下代码所示：
```javascript
	// 用一个全局变量存储被注册的副作用函数
	let activeEffect
	// effect 函数用于注册副作用函数
	function effect(fn) {
		//当调用 effect 注册副作用函数时，将副作用函数fn赋值给activeEffect
		activeEffect = fn
		//执行副作用函数
		fn()
	｝
```
我们可以按照如下所示的方式使用 effect 函数：

```javascript
	effect(
		// 一个匿名的副作用函数
		()=>{
			document.body.innerText = obj.text
		}
	)
```
可以看到，我们使用一个匿名的副作用函数作为 effect 函数的参数。当 effect 函效执行时，首先会把匿名的副作用函数 fn 賦值给全局变量activeEffect。接着执行被注册的匿名副作用函数 fn，这将会触发响应式数据obj.text 的读取操作，进而触发代理对象 Proxy 的get 拦截函数：

```javascript
	const obj = new Proxy(data, {
		get(target,key)
			//将 activeEffect 中存储的副作用函数收集到“桶”中
			if (activeEffect){	//新增
				bucket.add(activeEffect)//	新增
			}	//新增
			return target [key]
		},
		set(target, key, newVal) {
			target[key] = newVal
			bucket. forEach(fn => fn())
			return true
		}
	})
```
如上面的代码所示，由于副作用函数已经存储到了 activeEffect 中，所以在get 拦截函数内
应该把 activeEffect 收集到“桶”中，这样响应系统就不依赖副作用函数的名字了。

进一步测试这个系统，如果为对象obj添加新的noExist属性：
```javascript
	effect(
		// 匿名副作用函数
		()=>{
			document.body.innerText = obj.text
		}
	)
	setTimeout(() => {
		//副作用函数中并没有读取 noExist 属性的值
		obj.noExist = 'hello vue3"
	},1000)
```
理论上，字段obj.noExist并没有与副作用建立响应联系，但实际上匿名副作用函数却重新执行了。导致该问题的根本原因是，我们没有在副作用函数与被操作的目标字段之间建立明确的联系。

为了解决这个问题，我们需要重新设计“桶”的数据结构。在上一节中，我们使用一个Set数据结构作为存储副作用函数的“桶”。
依照函数中存在的三个角色及其作用，我们建立一个树形数据结构。

> 被操作（读取）的代理对象 obj；
被操作（读取）的字段名 text；
使用 effect 函数注册的副作用函数 effectFn。

如果用 target 来表示一个代理对象所代理的原始对象，用 key 来表示被操作的字段名，用 effectFn 来表示被注册的副作用函数，为这三个角色建立树型结构，就可以解决前文提到的问题：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/766fc0d8b10349ee92a6e127396a4222.jpeg#pic_center =x70)
<center>图4-4 树型结构</center>

### 4. 分支切换与cleanup
首先，我们需要明确分支切换的定义，如下面的代码所示：
```javascript
	const data = ｛ ok: true,text：'hello world'｝
	const obj = new Proxy（data， ｛/*...*/｝）
	
	effect(function effectFn() {
	document. body. innerText = obj.ok ? obj.text : 'not'
	｝）
```
在 effectFn函数内部存在一个三元表达式，根据字段 obj.ok值的不同会执行不同的代码分支。当字段 obj.ok的值发生变化时，代码执行的分支会跟着变化，这就是所谓的分支切换。

分支切换可能会产生遗留的副作用函数。拿上面这段代码来说，字段 obj.ok 的初始值为 true ，这时会读取字段 obj.text 的值，所以当 effectFn 函数执行时会触发字段 obj.ok 和字段 obj.text 这两个属性的读取操作，此时副作用函数 effectFn 与响应式数据之间建立的联系如下：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5ae46c6a3c8546fdb44b6f83dfd42174.jpeg#pic_center =500x)
<center>图4-5 副作用函数与响应式数据之间的联系</center>

可以看到，副作用函数 effectFn 分别被字段 data.ok 和字段data.text 所对应的依赖集合收集。当字段obj.ok 的值修改为false，并触发副作用函数重新执行后，由于此时字段obj.text 不会被读取，只会触发字段obj.ok 的读取操作，所以理想情况下副作用函数 effectFn 不应该被字段obj.text 所对应的依赖集合收集，如图4-6所示。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/67d4330cabde4cf1bcdd067e39f9f041.jpeg#pic_center =500x)
<center>图4-6 理想情况下副作用函数与响应式数据之间的联系</center>

按照前文代码的实现，当我们把字段 obj.ok 的值修改为false，再修改 obj.text 的值会触发副作用函数重新执行，但此时  document.body.innerText 的值始终都是字符串 "not"， 这时就产生了遗留的副作用函数。
为了解决这个问题，我们可以在每次副函数执行时，先把它从所有与之关联的依赖集合中删除，如图4-7所示
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/363c69dfd49a40e493e1178d08f96079.jpeg#pic_center =500x)
<center>图4-7断开副作用函数与响应式数据之间的联系</center>
当副作用西数执行完毕后，会重新建立联系，但在新的联系中不会包含遗留的副作用函数，
即图4-6所描述的那样。
要将一个副作用函数从所有与之关联的依赖集合中移除，就需要明确知道哪些依赖集合中包含它，因此我们需要重新设计副作用函数，如下面的代码所示。在 effect 内部我们定义了新的 effectFn 函数，并为其添加了 effectFn.deps 属性，该属性是一个数组，用来存储所有包含当前副作用函数的依赖集合：

```javascript
// 用一个全局变量存储被注册的副作用函数
	Let activeEffect
	function effect(fn) {
		const effectFn = () = {
			//当 effectFn 执行时，将其设置为当前激活的副作用函数
			activeEffect = effectFn
			fn()
		}
		// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合
		effectFn.deps = []
		// 执行副作用函数
		effectFn()
	}
```
那么 effectFn.deps 数组中的依赖集合是如何收集的呢？其实是在 track 函数中：

```javascript
	function track(target, key) {
		// 没有 activeEffect，直接return
		if (! activeEffect) return
		let depsMap = bucket.get(target)
		if (! depsMap) {
			bucket.set(target, (depsMap = new Map()))
		}
		let deps = depsMap.get(key)
		if (!deps) {
			depsMap.set(key，(deps = new Set() ))
		}
		// 把当前激活的副作用函数添加到依赖集合 deps 中
		deps.add(activeEffect)
		// deps 就是一个与当前副作用函数存在联系的依赖集合
		// 将其添加到 activeEffect.deps 数组中
		activeEffect.deps.push(deps)// 新增
	｝
```
如以上代码所示，在track函数中我们将当前执行的副作用函数 activeEffect 添加到依赖集合deps 中，这说明 deps 就是一个与当前副作用函数存在联系的依赖集合，于是我们也把它添加到 activeEffect.deps 数组中，这样就完成了对依赖集合的收集。图4-8描述了这一步所建立的关系。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/aba113b6bae44c99b849661a32978876.jpeg#pic_center =500x)
<center>图4-8 对依赖集合的收集</center>
有了这个联系后，我们就可以在每次副作用函数执行时，根据 effectFn.deps 获取所有与之关联的依赖集合，进而将副作用函数从依赖集合中移除：
```javascript
	// 用一个全局变量存储被注册的副作用函数
	Let activeEffect
	function effect(fn) {
		const effectFn = () = {
			// 调用 cleanup 函数完成清除工作
			cleanup(effectFn) // 新增
			activeEffect = effectFn
			fn()
		}
		effectFn.deps = []
		effectFn()
	}
```
下面是 cLeanup 函数的实现：

```javascript
	function cleanup(effectFn) {
		// 遍历 effectFn.deps 数组
		for (let i = 0; i < effectFn.deps.length; i++) {
			// deps 是依赖集合
			const deps = effectFn.deps[i]|
			//将 effectFn 从依赖集合中移除
			deps.delete(effectFn)
		}
		// 最后需要重置 effectFn.deps 数组
		effectFn.deps.length = 0
	}
```

cleanup函数接收副作用函数作为参数，遍历副作用函数的 effectFn.deps 数组，该数组的每一项都是一个依赖集合，然后将该副作用函数从依赖集合中移除，最后重置 effectFn.deps数组。
至此，我们的响应系统已经可以避免副作用函数产生遗留了。但如果你尝试运行代码，会发现目前的实现会导致无限循环执行，问题出在 trigger 函数中：
```javascript
	function trigger(target, key) {
		const depsMap = bucket.get(target)
		if (!depsMap) return
		const effects = depsMap.get (key)
		effects && effects.forEach(fn => fn() )  //问题出在这向代码
	}
```
在 trigger函数内部，我们遍历 effects 集合，它是一个Set集合，里面存储着副作用函数。当副作用函数执行时，会调用 cleanup 进行清除，实际上就是从 effects 集合中将当前执行的副作用函数剔除，但是副作用函数的执行会导致其重新被收集到集合中，而此时对于 effects集合的遍历仍在进行。这个行为可以用如下简短的代码来表达：

```javascript
	const set = new Set([1])
	
	set. forEach( item => {
		set. delete(1)
		set. add (1)
		console.1og('遍历中')
		})
```

在上面这段代码中，我们创建了一个集合 set，它里面有一个元素数字1，接着我们调用forEach 遍历该集合。在遍历过程中，首先调用 delete(1) 删除数字1，紧接着调用 add(1)将数字1加回，最后打印“遍历中’。如果我们在浏览器中执行这段代码，就会发现它会无限执行下去。
语言规范中对此有明确的说明：在调用 forEach 遍历 Set 集合时，如果一个值已经被访问过了，但该值被删除并重新添加到集合，如果此时 forEach 遍历没有结束，那么该值会重新被访问。因此，上面的代码会无限执行。解决办法很简单，我们可以构造另外一个 Set 集合并遍历它：

```javascript
	const set = new Set([1])
	
	const newSet = new Set(set)
	newSet. forEach(item => {
		set.delete(1)
		set. add(1)
		console. log('遍历中')
	})
```
这样就不会无限执行了。回到 trigger函数，我们需要同样的手段来避免无限执行：
```javascript
	function trigger (target, key) {
		const depsMap = bucket.get(target)
		if (! depsMap) return
		const effects = depsMap.get (key)
		
		const effectsToRun = new Set(effects) // 新增
		effectsToRun. forEach(effectFn => effectFn() ) //新增
		// effects && effects.forEach(effectFn => effectFn() )// 删除
	}
```
如以上代码所示，我们新构造了 effectsToRun 集合并遍历它，代替直接遍历 effects 集合，从而避免了无限执行。
### 5. 嵌套的effect与effect栈
effect 是可以发生嵌套的。Vue.js 的渲染函数是在一个 effect 中执行的，当组件发生嵌套时，此时就发生了 effect 嵌套。
```javascript
// Foo 组件
	const Foo = {
	render() {
		return /*...*/
	}
}
```
在一个 effect 中执行 Foo 组件的渲染函数：
```javascript
	effect( () => {
		Foo. render ()
	})
```
当组件发生嵌套时，例如 Foo组件渲染了 Bar 组件：
```javascript
	// Bar 组件
	const Bar = {
		render(){ /*...*/ },
	}
	// Foo 组件渲染了 Bar 纽件
	const Foo = {
		render() {
			return <Bar /> // jsx 语法
		},
	}
```
此时就发生了 effect 嵌套，它相当于：
```javascript
	effect(() => {
		Foo.render()
		// 嵌套
		effect(() => {
			Bar.render()
		})
	})
```
这个例于说明了为什么 effect 要设计成可嵌套的。接下来，我们需要搞清楚，如果 effect 不支持嵌套会发生什么？实际上，按照前文的介绍与实现来看，我们所实现的响应系统并不支持effect 嵌套，可以用下面的代码来测试一下：

```javascript
	// 原始数据
	const data = { foo: true, bar: true }
	// 代理对象
	const obj = new Proxy(data, { /*...*/ })
	
	// 全局变量
	let temp1, temp2
	// cffectFn1 嵌套了 effectFn2
	effect(function effectFn1() {
		console. log('effectFn1 执行')
		
		effect(function effectFn2() {
		console.log( 'effectFn2 执行' ) //在 effectFn2 中读取 obj.bar 属性
		temp2 = obj.bar
		})
		// 在 effectFn1 中读取 obj.foo属性
		temp1 = obj.foo
	})
```
在上面这段代码中，effectFn1内部嵌套了 effectFn2，很明显，effectFn1 的执行会导致effectFn2的执行。需要注意的是，我们在 effectFn2 中读取了字段obj.bar，在 effectFn1 中读取了字段 obd.foo，并且 effectFn2的执行先于对字段ob.foo的读取操作。在理想情况下，我们希望副作用函数与对象属性之间的联系如下：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a68054d19a114160b08b4208f9770302.jpeg#pic_center =x100)
<center>图4-9 理想情况下 副作用函数与对象属性之间的联系</center>
在这种情况下，我们希望当修改 obj.f00时会触发 effectFn1 执行。由于 effectFn2 嵌套在effectFn1 里，所以会间接触发 effectFn2执行，而当修改obj.bar 时，只会触发 effectFn2执行。

但结果不是这样的，我们尝试修改obj.foo 的值，会发现输出为：

> 'effectFn1 执行'
> 'effectFn2 执行'
> 'effectFn2 执行'

一共打印三次，前两次分别是副作用函数 effectFn1 与 effectFn2 初始执行的打印结果，到这一步是正常的，问题出在第三行打印。我们修改了字段obj.foo的值，发现 effectFn1 并没有重新执行，反而使得 effectFn2 重新执行了，这显然不符合预期。
问题出在哪里呢？其实就出在我们实现的effect 函数与 activeEffect 上。观察下面这段代码：
```javascript
	// 用一个全局变量存储当前激活的 effect 函数
	let activeEffect
	function effect(fn) {
		const effectFn = () => {
			cleanup(effectFn)
			// 当调用 effect 注册副作用函数时，将副作用函数賦值给 activeEffect
			activeEffect = effectFn
			fn()
		}
		// activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合
		effectFn.deps = []
		// 执行副作用函数
		effectFn()
	}
```
我们用全局变量 activeEffect 来存储通过 effect 函数注册的副作用函数，这意味着同一时刻 activeEffect 所存储的副作用函数只能有一个。当副作用函数发生嵌套时，内层副作用函数的执行会覆盖 activeEffect 的值，并且永远不会恢复到原来的值。这时如果再有响应式数据进行依赖收集，即使这个响应式数据是在外层副作用函数中读取的，它们收集到的副作用函数也都会是内层副作用函数，这就是问题所在。
为了解决这个问题，我们需要一个副作用函数栈 effectstack，在副作用函数执行时，将当前副作用函数压入栈中，待副作用函数执行完毕后将其从栈中弹出，并始终让 activeEffect 指向栈顶的副作用函数。这样就能做到一个响应式数据只会收集直接读取其值的副作用函数，而不会出现互相影响的情况，如以下代码所示：
```javascript
	// 用一个全局变量存储当前激活的 effect 函数
	Let activeEffect
	// effect 栈
	const effectstack = []  // 新增
	
	function effect(fn){
		const effectFn = () => {
			cleanup(effectFn)
			// 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect
			activeEffect = effectFn
			// 在调用副作用函数之前在当前副作用函数压入栈中
			effectStack.push(effectFn)// 新增
			// 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把 activeEffect还原为之前的值
			effectstack.pop() // 新增
			activeEffect = effectStack[effectStack.length - 1] // 新增
		}
		// activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合
		effectFn.deps = []
		// 执行副作用函数
		effectFn()
	}
```
我们定义了 effectStack 数组，用它来模拟栈，activeEffect 没有变化，它仍然指向当前正在执行的副作用函数。不同的是，当前执行的副作用函数会被压入栈顶，这样当副作用函数发生嵌套时，栈底存储的就是外层副作用函数，而栈顶存储的则是内层副作用函数，如图4-10左图所示。
当内层副作用函数 effectFn2 执行完毕后，它会被弹出栈，并将副作用函数 effectFn1 设置为 activeEffect，如图4-10右图所示。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/eae6cf3e2e754c1c83dcc60cfd6d1f0e.jpeg#pic_center =x200)
<center>图4-10 副作用函数栈  &  副作用函数从栈中弹出</center>
如此一来，响应式数据就只会收集直接读取其值的副作用函数作为依赖，从而避免发生错乱。

### 6. 避免无限递归循环
一个无限递归循环例子：
```javascript
	const data = { foo: 1 }
	const obj = new Proxy( data, { /*...*/ } )
	
	effect => obj. foo++)
```
可以看到，在effect 注册的副作用函数内有一个自增操作obj.foo++，该操作会引起栈溢出：
>	 Uncaught RangeError: Maximum call stack size exceeded
>
为什么会这样呢？接下来我们就尝试搞清楚这个问题，并提供解决方案。
实际上，我们可以把 obj.foo++这个自增操作分开来看，它相当于：
```javascript
	effect( ()=>{ 
		// 语句
		obj.foo = obj.foo + 1
	})
```
在这个语句中，既会读取obj.foo 的值，又会设置obj.foo的值，而这就是导致问题的根本原因。我们可以尝试推理一下代码的执行流程：首先读取 obj.foo 的值，这会触发 track 操作，将当前副作用函数收集到“桶”中，接着将其加1后再赋值给 obj. foo，此时会触发 trigger 操作，即把“桶”中的副作用函数取出并执行。但问题是该副作用函数正在执行中，还没有执行完半，就要开始下一次的执行。这样会导致无限递归地调用自己，于是就产生了栈溢出。

解决办法并不难。通过分析这个问题我们能够发现，读取和设置操作是在同一个副作用函数内进行的。此时无论是 track 时收集的副作用函数，还是 trigger 时要触发执行的副作用函数，都是 activeEffect 。基于此，我们可以在 trigger 动作发生时增加守卫条件：如果 trtgger 触发执行的邮作用函数乌当前正在执行的副作用函数相同，则不触发执行，如以下代码所示：
```javascript
	function trigger (target, key) {
		const depsMap = bucket.get(target)
		if (! depsMap) return
		const effects = depsMap.get(key)
		
		const effectsToRun = new Set
		effects && effects.forEach( effectFn =>{
			// 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，則不触发执行 
			if (effectFn ! == activeEffect){ // 新增
				effectsToRun.add(effectFn)
			}
		})
		effectsToRun. forEach(effectFn => effectFn())
		// effects && effects. forEach(effectFn => effectFn())
	}
```
这样我们就能够避免无限递归调用，从而避免栈溢出。
### 7. 执行调度

可调度性是响应系统非常重要的特性。首先我们需要明确什么是可调度性。所谓可调度，指的是当trigger动作触发副作用函数重新执行时，有能力决定副作用函数执行的时机、次数以及方式。
首先来看一下，如何决定副作用函数的执行方式，以下面的代码为例：
```javascript
	const data = { foo: 1}
	const obj = new Proxy(data,｛ /*...*/} )
	effect( ()=>
		console.log(obj.foo)
	obj.foo++
	console.Log('结束了')
```
在副作用函数中，我们首先使用 console.Log 语句打印 obj.foo 的值，增操作，最后使用 console.log 语句打印‘结束了'。这段代码的输出结果如下：
> 1
> 2 
> 结束了
> 
响应系统支持调度，可以实现在不调整代码的情况下调整输出顺序。我们可以为 effect 函数设计一个选项参数 options，允许用户指定调度器：

```javascript
	effect(
		()=>{
			console.log(obj.foo)
		},
		//options
		{
			// 调度器 scheduler 是一个函数
			scheduler(fn){
				//...
			}
		}
	)
```

如上面的代码所示，用户在调用 effect 函数注册副作用函数时，可以传递第二个参数options。它是一个对象，其中允许指定 scheduler 调度函数，同时在 effect 函数内部我们需要把 options 选项挂载到对应的副作用函效上：
```javascript
	function effect(fn, options = {} ){
			const effectFn = () => {
				cleanup(effectFn)
				// 当调用 effect 注册副作用函数时，将副作用函教赋值给 activeEffect
				activeEffect = effectFn
				// 在调用副作用函数之前将当前副作用函数压栈
				effectStack.push（effectFn）
				fn()
				// 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect还原为之前的值
				effectStack.pop()
				activeEffect = effectStack[ effectStack.length - 1 ]
			｝
			// 将 options 挂载到 effectFn 上
			effectFn.options = options // 新增
			// activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合
			effectFn.deps = []
			// 执行副作用函数
			effectFn()
		}
```
有了调度函数，在 trigger 函数中触发副作用函数重新执行时，就可以直接调用用户传递的调度器函数，从而把控制权交给用户：

```javascript
function trigger(target, key){
	const depsMap = bucket.get(target)
	if (! depsMap) return
	const effects = depsMap.get(key)
	
	const effectsToRun = new Set()
	effects && effects.forEach( effectFn =>{ 
		if ( effectFn != activeEffect ){
			effectsToRun.add(effectFn)
		}
	})
	effectsToRun.forEach(effectFn =>{
		// 如果一个副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递
		if (effectFn.options.scheduler){ //新增
			effectFn.options.scheduler(effectFn) // 新增
		} else {
			// 否则直接执行副作用函数(之前的默认行为)
			effectFn() // 新增
		}
	})
)
```

如上面的代码所示，在trigger 动作触发副作用函数执行时，我们优先判断该副作用函数是否存在调度器，如果存在，则直接调用调度器函数，并把当前副作用函数作为参数传递过去，由用户自己控制如何执行；否则保留之前的行为，即直接执行副作用函数。
有了这些基础设施之后，我们就可以实现前文的需求了，如以下代码所示：

```javascript
const data = { foo: 1 }
const obj = new Proxy(data, { /* ... */ })

effect(
	()=>{
		console.log(obj.foo)
	},
	// options
	{
		// 调度器 scheduler 是一个函数
		scheduler(fn){
			// 将副作用函数放到宏任务队列中执行
			setTimeout(fn)
		}
	}
)

obj.foot++

console.Log('结束了')
```
我们使用 setTimeout 开启一个宏任务来执行副作用函数fn，这样就能实现期望的打印顺序了:

> 1 
> '结束了' 
> 2

除了控制副作用函数的执行顺序，通过调度器还可以做到控制它的执行次数，这一点也尤为重要。我们思考如下例子：

```javascript
const data = { foo: 1 }
const obj = new Proxy(data, { /*...*/ } )
effect( ()=>{
console.log(obj.foo)
})

obj.foo++
obj.foo++
```

首先在副作用函数中打印obj.foo的值，接着连续对其执行两次自增操作，在没有指定调度器的情况下，它的输出如下：

> 1 
> 2 
> 3

由输出可知，字段obj.foo的值一定会从1自增到3，2只是它的过渡状态。如果我们只关心最终结果而不关心过程，那么执行三次打印操作是多余的，我们期望的打印结果是：

> 1
> 3

其中不包含过渡状态，基于调度器我们可以很容易地实现此功能：

```javascript
	// 定义一个任务队列
	const jobQueue = new Set()
	// 使用 Promise.resolve()创建一个promise 实例，我们用它将一个任务添加到微任务队列
	const p = Promise.resolve()
	// 一个标志代表是否正在刷新队列
	
	Let isFlushing = false
	function flushJob() {
		// 如果队列正在刷新，则什么都不做
		if (isFlushing) return
		// 设置为 true，代表正在刷新
		// 在微任务队列中刷新 jobQueue 队列
		p.then( () => {
			jobQueue.forEach( job => job() )
		}). finally( () = {
			// 结束后重置 isFlushing
			isFlushing = false
		})
	}
	effect( () => {
		console. log(obj.foo)
	},{
		scheduler(fn){
			// 每次调度时，将副作用函数添加到 jobQueve 队列中
			jobQueue.add(fn)
			//调用 flushJob 刷新队列
			flushJob()
		}
	})
	
	obj .foo++
	obj .foo++
```

观察上面的代码，首先，我们定义了一个任务队列 jobQueue，它是一个 set 数据结构，目的是利用 Set 数据结构的自动去重能力。接着我们看调度器 scheduler 的实现，在每次调度执行时，先将当前副作用函数添加到 jobQueue 队列中，再调用 flushJob函数刷新队列。然后我们把目光转向 flushJob 函数，该函数通过 isFlushing 标志判断是否需要执行，只有当其为 false 时才需要执行，而一旦 flushJob 函数开始执行，isFlushing 标志就会设置次true，意思是无论调用多少次 flushJob 函数，在一个周期内都只会执行一次。需要注意的是，在 flushJob 内通过 p.then 将一个函数添加到微任务队列，在微任务队列内完成对 jobQueue 的遍历执行。
整段代码的效果是，连续对 obj.foo执行两次自增操作，会同步且连续地执行两次 scheduler 调度函数，这意味着同一个副作用函数会被 jobQueve.add(fn) 语句添加两次，但由于 Set 数据结构的去重能力，最终 jobQueue 中只会有一项，即当前副作用函数。类似地，flushJob 也会同步且连续地执行两次，但由于 isFlushing 标志的存在，实际上 flushJob 函数在一个事件循环内只会执行一次，即在微任务队列内执行一次。当微任务队列开始执行时，就会遍历 jobQueue 并执行里面存储的副作用函数。由于此时 jobQueue 队列内只有一个副作用函数，所以只会执行一次，并且当它执行时，字段obj.fo。的值已经是3了，这样我们就实现了期望的输出：

>1
> 3

可能你已经注意到了，这个功能有点类似于在 Vue.js 中连续多次修改响应式数据但只会触发一次更新，实际上Vue.js 内部实现了一个更加完善的调度器，思路与上文介绍的相同。
### 8. 计算属性computed与lazy
前文介绍了 effect 函数，它用来注册副作用函数，同时它也允许指定一些选项参数 options，例如指定 scheduler 调度器来控制副作用函数的执行时机和方式；也介绍了用来追踪和收集依赖的 track 函数，以及用来触发副作用函数重新执行的 trigger函数。实际上，综合这些内容，就可以实现 Vue.jis 中一个非常重要并且非常有特色的能力——计算属性。

懒执行的 effect，即 lazy 的 effect 。举个例子，现在我们所实现的 effect 函数会立即执行传递给它的副作用函数，

```javascript
	effect(
		// 这个函数会立即执行
		() => {
			console. log(obj.foo)
		}
	)
```

但在有些场景下，我们并不希望它立即执行，而是希望它在需要的时候才执行，例如计算属性。这时我们可以通过在 options 中添加 lazy 属性来达到目的，如下面的代码所示：

```javascript
	effect(
		// 指定了 lazy 选项，这个函数不会立即执行
			console.log(obj.foo)
		},
		// options
		{
			lazy: true
		}
	)
```

lazy 选项和之前介绍的 scheduler 一样，它通过options 选项对象指定。有了它，我们就可以修改 effect 函数的实现逻辑了，当options.lazy 为 true 时，则不立即执行副作用函数：

```javascript
	function effect(fn, options =() ){
			const effectFn = () = {
			cleanup(effectFn)
			activeEffect = effectFn
			effectStack.push(effectFn)
			fn()
			effectStack.pop()
			activeffect = effectStack[ effectStack.length - 1 ]
		｝
		effectFn.options = options
		effectFn.deps = []
		// 只有非 lazy 的时候，才执行
		if (! options.lazy)｛ // 新增
			// 执行副作用函数
			effectFn()
		｝
		// 将副作用函数作为返回值返回
		return effectFn // 新增
	}
```

通过这个判断，我们就实现了让副作用函数不立即执行的功能。但问题是，副作用函数应该什么时候执行呢？通过上面的代码司以看到，我们将翻作用函数 effectFn 作 effest 函教的返回值，这就意味着当调用 effect 函数时，通过其返回值能够拿到对应的副作用函数，这样我们就能手动执行该副作用函数了：

```javascript
	const effectFn = effect( ()=>{
		console.log(obj.foo)
	}, { lazy: true })
	
	// 手动执行副作用函数
	effectFn()
```

如果仅仅能够手动执行副作用函数，其意义并不大。但如果我们把传递给 effect 的函数看作一个 getter，那么这个 getter 函数可以返回任何值，例如：

```javascript
	const effectFn = effect
		// getter 返回 obj.foo 与obj.bar 的和
		() => obj.foo + obj.bar,
		{ lazy: true }
	)
	// value 是 getter 的返回值
	const value = effectFn()
```

这样我们在手动执行副作用函数时，就能够拿到其返回值：

```javascript
	const effectFn = effect(
		// getter 返回 obj.foo 与 obj.bar 的和
		() => obj.foo + obj.bar,
		{ lazy: true }
	)
	// value 是 getter 的返回值
	const value = effectFn()
```

为了实现这个目标，我们需要再对effect 函数做一些修改，如以下代码所示：

```javascript
	function effect(fn, options = {} ) {
		const effectn = () => {
			cleanup(effectFn)
			activeEffect = effectFn
			effectStack.push(effectFn)
			// 将 fn 的执行结果存储到 res 中
			const res = fn() // 新增
			effectStack.pop()
			activeEffect = effectStack[ effectStack.length - 1 ]
			// 将 res 作为 effectFn 的返回值
			return res // 新增
		}
		effectFn.options = options
		effectFn.deps = []
		if (! options.lazy ) {
			effectFn()
		}
		return effectFn
	｝
```

通过新增的代码可以看到，传递给 effect 函数的参数 fn 才是真正的副作用函数，而 effectFn 是我们包装后的副作用函数。为了通过 effectFn 得到真正的副作用函数 fn的执行结果，我们需要将其保存到 res 变量中，然后将其作为 effectFn 函数的返回值。
现在我们已经能够实现懒执行的副作用函数，并且能够拿到副作用函数的执行结果了，接下来就可以实现计算属性了，如下所示：

```javascript
	function computed(getter) {
		// 把 getter 作为副作用函数，创建一个 lazy 的 effect
		const effectn = effect(getter, {
			lazy: true
		})
		
		const obj = {
			// 当读取 value 时才执行 effectFn
			get value() {
				return effectFn()
			}
		}
		return obj
	}
```

首先我们定义一个 computed 函数，它接收一个 getter 函数作为参数，我们把 getter 函数作为副作用函数，用它创建一个 lazy 的 effect。computed 函数的执行会返回一个对象，该对象的 value 属性是一个访问器属性，只有当读取 value 的值时，才会执行effectFn 并将其结果作为返回。
我们可以使用 computed 函数来创建一个计算属性：

```javascript
	const data = { foo: 1, bar: 2 }
	const obj = new Proxy( data, { /*…*/} )
	
	const sumRes = computed( ()=> obj.foo + obj.bar )
	
	console.log(sumRes.value) // 3
```

可以看到它能够正确地工作。不过现在我们实现的计算属性只做到了懒计算，也就是说，只有当你真正读取 sumRes.value 的值时，它才会进行计算并得到值。但是还做不到对值进行缓存，即假如我们多次访问 sumRes.value 的值，会导致 effectFn 进行多次计算，即使 obj.foo 和 obj.bar 的值本身并没有变化：

```javascript
	console. log(sumRes.value) // 3
	console. log(sumRes.value) // 3
	console. log(sumRes.value) // 3
```


上面的代码多次访问 sumRes.value 的值，每次访问都会调用 effectFn 重新计算。
为了解决这个问题，就需要我们在实现 computed 函数时，添加对值进行缓存的功能，如以下代码所示：

```javascript
	function computed(getter) {
		// value 用来缓存上一次计算的值
		let value
		// dirty 标志，用来标识是否需要重新计算值，为 true 则意味着“脏”，需要计算
		let dirty = true
		
		const effectn = effect(getter, {
			lazy: true
		})
		
		const obj = {
			get value() {
				// 只有“脏”时才计算值，并将得到的值缓存到 value 中
				if (dirty) {
					value = effectFn()
					// 将 dirty 设置为 false ，下一次访问直接使用缓存到 value 中的值
					dirty = false
				}
				return value
			}
		}
		
		return obj
	}
```

我们新增了两个变量 value 和 dirty，其中 value 用来缓存上一次计算的值，而 dirty 是一个标识，代表是否需要重新计算。当我们通过 sumRes.value 访问值时，只有当 dtrty 为 true 时才会调用 effectFn 重新计算值，否则直接使用上一次缓存在 value 中的值。这样无论我们访问多少次 sumRes/value，都只会在第一次访问时进行真正的计算，后续访问都会直接读取缓存的value值。
但如果此时我们修改 obj.foo 或 obj.bar 的值，再访问 sumRes.value 会发现访问到的值没有发生变化：

```javascript
	const data = { foo: 1, bar: 2 }
	const obj = new Proxy(data, { /* ... */ } )
	
	const sumes = computed( () = obj.foo + obj.bar)
	console. log(sumRes.value) // 3
	console. log(sumRes.value) // 3
	
	// 修改 obj.foo
	obj.foo++
	
	// 再次访问，得到的仍然是 3，但预期结果应该是4
	console. log(sumRes.value) // 3
```

这是因为，当第一次访问 sumRes.value 的值后，变量 dirty 会设置次 false，代表不需要计算。即使修改了 obj.foo 的值，但只要 dirty 的值为 false ，就不会重新计算，导致得到了错误的值。
解决办法：当 obj.foo 或 obj.bar 的值发生变化时，只要 dirty 的值重置为 true 就可以了。这用到了上一节介绍的 scheduler 选项，如以下代码所示：

```javascript
	function computed (getter) {
		let value
		let dirty = true
		
		const effectFn = effect(getter, {
			lazy: true,
			// 添加调度器，在调度器中将 dirty 重置为 true
			scheduler() {
				dirty = true
			}
		})
		
		const obj = {
			get value() {
				if (dirty) {
					value = effectFn()
					dirty = false
				}
				return value
			}
		}
		
		return obj
	}
```

我们为 effect 添加了 scheduler 调度器函数，它会在 getter 函数中所依赖的响应式数据变化时执行，这样我们在 scheduler 函数内将 dirty 重置为 true，当下一次访问 sumRes.value 时，就会重新调用 effectFn 计算值，这样就能够得到预期的结果了。
现在，我们设计的计算属性已经趋于完美了，但还有一个缺陷，它体现在当我们在另外一个effect 中读取计算属性的值时：

```javascript
	const sumRes = computed( () => obj.foo + obj.bar)
	
	effect( ()=>{
		// 在该副作用函数中读取 sunRes.value
		console.log(sumRes.value)
	})
	
	// 修改 obj.foo 的值
	obj.foo++
```

如以上代码所示，sunRes 是一个计算属性，并且在另一个 effect 的副作用函数中读取了 sumRes.value 的值。如果此时修改  obj.foo 的值，我们期望副作用函数重新执行，就像我们在 Vue.js 的模板中读取计算属性位的时候，一旦计算属性发生变化就会触发重新渲染一样。但是如果尝试运行上而这段代码，会发现修改 obj.foo 的值并不会触发副作用函数的渲染，因此我们说这是一个缺陷。

分析问题的原因，我们发现，从本质上看这就是一个典型的 effect 嵌套。一个计算属性内部拥有自己的 effect ，并且它是懒执行的，只有当真正读取计算属性的值时才会执行。对于计算属性的 getter 函数来说，它里面访问的响应式数据只会把 computed 内部的 effect 收集为依赖。而当把计算属性用于另外一个 effect 时，就会发生 effect 嵌套，外层的 effect 不会被内层 effect 中的响应式数据收集。

解决办法很简单。当读取计算属性的值时，我们可以手动调用 track 函数进行追踪；当计算属性依赖的响应式数据发生变化时，我们可以手动调用 trigger 函数触发响应：

```javascript
	function computed(getter) (
		let value
		let dirty = true
		
		const effectFn= effect(getter,{
			lazy: true, 
			scheduler() {
				if(! dirty) {
					dirty = true
					// 当计算属性依赖的响应式数据变化时，手动调用 trigger 函数触发响应
					trigger(obj, 'value')
				}
			}
		})
		
		const obj = {
			get value(){
				if (dirty) {
					value = effectFn()
					dirty = false
				}
				// 当读取 value 时，手动调用 track 函数进行追踪
				track(obj, 'value')
				return value
			}
		}
		return obj
	}
```

如以上代码所示，当读取一个计算属性的 value 值时，我们手动调用 track 函数，把计算属性返回的对象 obj 作为 target，同时作为第一个参数传递给 track 函数。当计算属性所依赖响应式数据变化时，会执行调度器函数，在调度器函数内手动调用 trigger 函数触发响应即可。这时，对于如下代码来说：

```javascript
	effect(function effectFn() {
		console.log(sumRes.value)
	}）
```
它会建立这样的联系：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/39ed652e38994d7a94b2b9135d2c97a5.jpeg#pic_center =x60)
图4-11给出了更详细的描述。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a2de1a52fe1d45f2b66bff6f77a3bb72.jpeg#pic_center =x300)
<center>图4-11 计算属性的响应联系</center>

### 9. watch的实现原理
watch 其本质就是观测一个响应式数据，当数据发生变化时通知并执行相应的回调函
数。举个例子：

```javascript
	watch(obj, () => {
		console. Log('数据变了')
	})
	
	// 修改响应数据的值，会导致回调函数执行
	obj.foo++
```

假设 obj 是一个响应数据，使用 watch 函数观测它，并传递一个回调函数，当修改响应式数
据的值时，会触发该回调函数执行。
实际上，watch 的实现本质上就是利用了 effect 以及 options.scheduler 选项，如以下代码
所示：
```javascript
	effect( () => {
		console.log(obj. foo)
	},{
		scheduler(){
			// 当 obj.foo 的值变化时，会执行 scheduler 调度函数
		}
	})
```
在一个副作用函数中访问响应式数据 obj.foo，通过前面的介绍 ，我们知道这会在副作用函数与响应式数据之间建立联系，当响应式数据变化时，会触发副作用函数重新执行。但有一个例外，即如果副作用函数存在 scheduler 选项，当响应式数据发生变化时，会触发 scheduler 调度函数执行，而非直接触发酬作用函数执行。从这个角度来看，其实 scheduler 调度雨效就相当于一个回调函数，而 watch 的实现就是利用了这个特点。下面是最简单的 watch 函数的实现：

```javascript
	// watch函数接收两个参数，source 是响应式数据，cb 是回调函数
	function watch(source,cb){
		effect(
			// 触发读取操作，从而建立联系
			() => source.foo，
			{
				scheduler(){
					// 当数据变化时，调用回调函数 cb
					cb()
				}
			}
		)
	}
```

我们可以如下所示使用 watch 函数：

```javascript
	const data = { foo: 1 }
	const obj = new Proxy(data，{ /*...*/ } )
	
	watch(obj, () = {
		console.log('数据变化了')
	})
	
	obj.foo++
```

上面这段代码能正常工作，但是我们注意到在 watch 函数的实现中，硬编码了对 source.foo的读取操作。换句话说，现在只能观测obj.foo的改变。为了让 watch 函数具有通用性，我们需要一个封装一个通用的读取操作：

```javascript
	function watch(source, cb){
		effect(
			// 调用 traverse 递归地读取
			() => traverse(source),
			{
				scheduler() {
					// 当数据变化时，调用回调函数cb
					cb()
				}
			}
		)
	}
	
	function traverse(value, seen = new Set() ){
		// 如果要读取的数据是原始值，或者已经被读取过了，那么什么都不做
		if (typeof value ！== 'object' || value == nulL || seen.has(value) ) 
		return 
		// 将数据添加到 seen中，代表遍历地读取过了，避免循环引用引起的死循环
		seen.add(value)
		// 暂时不考虑数数组等其他结构
		// 假设 value 就是一个对象，使用 for..in 读取对象的每一个值，并递归地调用 traverse 进行处理
		for (const k in value) {
			traverse(value[k], seen)
		}
		
		return value
	}
```

如上面的代码所示，在 watch 内部的 effect 中调用 traverse 函数进行递归的读取操作，代替硬编码的方式，这样就能读取一个对象上的任意属性，从而当任意属性发生变化时都能够触发回调函数执行。
watch 函数除了可以观测响应式数据，还可以接收一个 getter 函数：

```javascript
	watch
		// getter 函数
		()=> obj.foo,
		// 回调函数
		()=>{
			console.log('obj.foo 的值变了')
		}
	)
```

如以上代码所示，传递给 watch 函数的第一个参数不再是一个响应式数据，而是一个 getter 函数。在 getter 函数内部，用户可以指定该 watch 依赖哪些响应式数据，只有当这些数据变化时，才会触发回调函数执行。如下代码实现了这一功能：

```javascript
	function watch(source, cb) {
		// 定义 getter
		let getter
		// 如果 source 是函数，说明用户传递的是 getter，所以直接把 source 赋值给 getter
		if (typeof source === 'function' ){
			getter = source
		} else{
			// 否则按照原来的实现调用 traverse 递归地读取
			getter = () => traverse(source)
		}
		
		effect(
			// 执行 getter
			() => getter(),
			{
				scheduler() {
					cb()
				}
			}
		)
	}
```

首先判断 source的类型，如果是函数类型，说明用户直接传递了 getter 函数，这时直接使用用户的 getter 函数；如果不是函数类型，那么保留之前的做法，即调用 traverse 函数递归地该取。这样就实现了自定义 getter 的功能，同时使得 watch 函数更加强大。

现在的实现还缺少一个非常重要的能力，即在回调函数中拿不到旧值与新值。通常我们在使用Vuejs 中的 watch 函数时，能够在回调函数中得到变化前后的值：

```javascript
	watch(
		() => obj.foo, (newValue,
		( newValue, oldValue) => {
			console.log(newValue, oldValue) // 2,1
		}
	)
	obj.foo++
```

那么如何获得新值与旧值呢？这需要充分利用effect 函数的lazy 选项，如以下代码所不：

```javascript
	function watch(source, cb) {
		let getter
		if (typeof source == 'function' ){
			getter = source
		} else {
			getter = () => traverse(source)
		}
		// 定义旧值与新值
		let oldValue, newValue
		// 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中以便后续手动调用
		const effectn = effect(
			() => getter(),
			{
				lazy: true
				scheduler(){
					// 在 scheduler 中重新执行副作用函数，得到的是新值
					newValue = effectFn()
					// 将旧值和新值作为回调函数的参数
					cb(newValue, oldValue)
					// 更新旧值，不然下一次会得到错误的旧值
					oldValue = newValue
				}
			}
		)
		// 手动调用副作用函数，拿到的值就是旧值
		oldValue = effectFn()
	｝
```

在这段代码中，最核心的改动是使用 lazy 选项创建了一个懒执行的effect。注意上面代码中最下面的部分，我们手动调用effectFn函数得到的返回值就是旧值，即第一次执行得到的值。当变化发生并触发 scheduler 调度函数执行时，会重新调用effectFn 函数并得到新值，这样我们就拿到了旧值与新值，接着将它们作力参数传递给回调函数cb就可以了。最后一件非常重要的事情是，不要忘记使用新值更新旧值：oldvalue = newvalue，否则在下一次变更发生时会得到错误的旧值。
### 10. 立即执行的watch与回调执行时机

上一节中我们介绍了 watch 的基本实现。在这个过程中我们认识到，watch 的本质其实是对 effect 的二次封装。本节我们继续讨论关于 watch 的两个特性：一个是立即执行的回调函数，另一个是回调函数的执行时机。

首先来看立即执行的回调函数。默认情况下，一个 watch 的回调只会在响应式数据发生变化时才执行：

```javascript
// 回调函数只有在响应式数据 obj后续发生变化时才执行
watch(obj，()=>
	console.log('变化了'）
})
```

在 Vuejs 中可以通过选项参数 immediate 来指定回调是否需要立即执行：

```javascript
watch(obj, () = {
	console.log('变化了')
},{
	// 回调函数会在 watch 创建时立即执行一次
	immediate: true
})
```

当 immediate 选项存在并且 true 时，回调函数会在该 watch 创建时立刻执行一次。仔细思考就会发现，回调函数的立即执行与后续执行本质上没有任何差别，所以我们可以把 scheduler 调度函数封装为一个通用函数，分别在初始化和变更时执行它，如以下代码所示：

```javascript
	function watch(source, cb, options = {} ) {
		let getter
		if (typeof source === 'function') {
			getter = source
		} else {
			getter = () => traverse(source)
		}
		let oldValue, newValue
		
		// 提取 scheduler 調度函數为一个独立的 job 函数
		const job = () => {
			newValue = effectFn()
			cb(newValue, oldValue)
			oldValue = newValue
		}
		
		const effectFn = effect(
			// 执行 getter
			()=> getter(),
			{
				lazy: true,
				// 使用 job 函数作为调度器函数
				scheduler: job
			}
		)
		if (options. immediate) {
		// 当 immediate 为 true 时立即执行 job，从而触发回调执行
			job()
		} else {
			oldValue = effectFn()
		}
	}
```

这样就实现了回调函数的立即执行功能。由于回调函数是立即执行的，所以第一次回调执行时没有所谓的旧值，因此此时回调函数的 oldvalue 值为 undefined ，这也是符合预期的。

除了指定回调函数为立即执行之外，还可以通过其他选项参数来指定回调函数的执行时机，例如在 Vue.js3 中使用 flush 选项来指定：

```javascript
	watch(obj, () = {
		console.log('变化了')
	},{
		// 回调函数会在 watch 创建时立即执行一次
		flush: 'pre' // 还可以指定为'post' I 'sync'
	})
```

flush 本质上是在指定调度函数的执行时机。前文讲解过如何在微任务队列中执行调度函数 scheduler ，这与 flush 的功能相同。当 flush 的值为 'post' 时，代表调度函数需要将副作用函数放到一个微任务队列中，并等待 DOM 更新结束后再执行，我们可以用如下代码进行模拟：

```javascript
	function watch(source, cb, options = {}) {
		let getter
		if (typeof source === 'function') {
			getter = source
		} else {
			getter = () => traverse(source)
		}
		
		let oldValue, newValue
		
		const job = () => {
			newValue = effectFn()
			cb(newValue, oldValue)
			oldValue = newValue
		}
		
		const effectFn = effect(
			// 执行 getter
			() => getter(),
			{
				lazy: true,
				scheduler: () => {
					// 在调度函数中判断 flush 是否为'post'，如果是，将其放到微任务队列中执行
					if (options.flush === 'post'){
						const p = Promise. resolve()
						p.then (job)
					} else {
						job()
					}
				}
			}
		)
		
		if (options. immediate) {
			job()
		} else {
			oldValue = effectFn()
		}
	}
```

如以上代码所示，我们修改了调度器函数 scheduler 的实现方式，在调度器函数内检测
options.flush 的值是否为 post，如果是，则将 job 函数放到微任务队列中，从而实现异步延迟执行；否则直接执行 job 函数，这本质上相当于 ‘sync' 的实现机制，即同步执行。对于 options.flush 的值为 'pre' 的情况，我们暂时还没有办法模拟，因为这涉及组件的更新时机，其中 'pre' 和 'post' 原本的语义指的就是组件更新前和更新后，不过这并不影响我们理解如何控制回调函数的更新时机。
### 11. 过期的副作用
竞态问题通常在多进程或多线程编程中被提及，举个例子：

```javascript
	let finalData
	
	watch(obj, async() => {
		// 发送并等待网络请求
		const res = await fetch('/path/to/request')
		// 将请求结果赋值给 data
		finalData = res
	}）
```

在这段代码中，我们使用 watch 观测 obj 对象的变化，每次 obj 对象发生变化都会发送网络请求，例如请求接口数据，等数据请求成功之后，将结果赋值给 finalData 变量。

上面的代码会发生竞态问题。假设我们第一次修改obj对象的某个字段值，这会导致回调函数执行，同时发送了第一次请求 A 。随着时间的推移，在请求 A 的结果返回之前，我们对 obj 对象的某个字段值进行了第二次修改，这会导致发送第二次请求 B 。此时请求 A 和请求 B 都在进行中，那么哪一个请求会先返回结果呢？如果请求 B 先于请求 A 返回结果，就会导致最终ftnalData 中存储的是A 请求的结果，如图4-12所示。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f210056093184310afa0455de96f1a98.jpeg#pic_center =x300)
<center>图4-12 请求A的结果覆盖请求B的结果</center>

但由于请求 B是后发送的，因此我们认为请求B返回的数据才是“最新”的，而请求A则应该被视为“过期”的，所以我们希望变盘 ftnalDsta 存储的值应该是由请求B返回的结果，而非请求 A 返回的结果。

实际上，我们可以对这个问题做进一步总结。请求 A 是副作用函数第一次执行所产生的副作用，请求 B 是副作用函数第二次执行所产生的副作用。由于请求 B 后发生，所以请求 B 的结果应该被视为“最新”的，而请求 A 已经“过期”了，其产生的结果应被视无效。通过这种方式，就可以避免竞态问题导致的错误结果。

在 Vue.js 中，watch 函数的回调函数接收第三个参数 onInvaltdate ，它是一个函数，类似于事件监听器，我们可以使用 onInvalidate 函数注册一个回调，这个回调函数会在当前副作用函数过期时执行：

```javascript
	watch(obj, async(newValue, oldValue, onInvalidate) => {
		// 定义一个标志，代表当前副作用函数是否过期，默认为 false，代表没有过期
		let expired = false
		// 调用 oninvalidate()函数注册一个过期回调
		onInvalidate(() => {
			// 当过期时，将 expired 设置为 true
			expired = true
		})
		
		// 发送网络请求
		const res = await fetch('/path/to/request')
		
		// 只有当该副作用函数的执行没有过期时，才会执行后续操作。
		if (! expired) (
			finalData = res
		}
	})
```

如上面的代码所示，在发送请求之前，我们定义了 expired 标志变量，用来标识当前副作用函数的执行是否过期；接着调用 onInvalidate 函数注册了一个过期回调，当该副作用函数的执行过期时将 expired 标志变量设置 true ；最后只有当没有过期时才采用请求结果，这样就可以有效地避免上述问题了。

onInvalidate 的原理：在 watch 内部每次检测到变更后，在副作用函数重新执行之前，会先调用我们通过 onInvalidate 函数注册的过期回调，如以下代码所示：

```javascript
	function watch( source, cb, options = {} ){
		let getter
		if (typeof source === 'function') }
			getter = source
		} else {
			getter = () => traverse(source)
		｝
		
		let oldValue, newValue
		
		// cleanup 用来存储用户注册的过期回调
		let cleanup
		// 定义 onInvalidate 函数
		function onInvalidate(fn) {
			// 将过期回调存储到 cleanup 中
			cleanup = fn
		}
		const job = () => {
			newValue = effectFn() 
			//在调用回调函数 cb 之前，先调用过期回调
			if (cleanup){
				cleanup()
			}
			 // 将 onInvalidate 作为回调函数的第三个参数，以便用户使用
			(newValue, oldvalue, onInvalidate)
			oldValue = newValue
		}
		
		const effectFn = effect(
			// 执行 getter
			() => getter(),
			{
				lazy: true,
				scheduler: () => {
					if (options.flush === 'post'){
						const p = Promise.resolve()
						p.then(job)
					} else {
						job()
					}
				}
			}
		)
		
		if (options.immediate) {
			job()
		} else {
			oldValue = effectFn()
		}
	}
```

在这段代码中，我们首先定义了 cleanup 变量，这个变量用来存储用户通过 onInvalidate 函数注册的过期回调。可以看到 onInvalidate 函数的实现非常简单，只是把过期回调赋值给了 cleanup 变量。这里的关键点在 job 函数内，每次执行回调函数 cb之前，先检查是否存在过期回调，如果存在，则执行过期回调函数 cleanup。最后我们把 onInvalidate 函数作为回调函数的第三个参数传递给cb，以便用户使用。还是通过一个例子来进一步说明：

```javascript
	watch(obj, async (newValue, oldValue, onInvalidate) => {
		let expired = false
		onInvalidate(() = {
			expired = true
		})
			
		const res = await fetch( '/path/to/request' )
		
		if (! expired) {
		finalData = res
		}
	})
		
	// 第一次修改
	obj.foo++
	setTimeout(() => {
	// 200ms 后做第二次修改
		obj.foo++
	}, 200)
```

如以上代码所示，我们修改了两次 obj.foo 的值，第一次修改是立即执行的，这会导致 watch 的回调函数执行。由于我们在回调函数内调用了 onInvalidate，所以会注册一个过期回调，接着发送请求 A。假设请求A需要1000ms 才能返回结果，而我们在 200ms 时第二次修改了 obj.foo 的值，这又会导致 watch 的回调函数执行。这时要注意的是，在我们的实现中，每次执行回调函数之前要先检查过期回调是否存在，如果存在，会优先执行过期回调。由于在 watch 的回调函数第一次执行的时候，我们已经注册了一个过期回调，所以在 watch 的回调函数第二次执行之前，会优先执行之前注册的过期回调，这会使得第一次执行的副作用函数内闭包的变量 expired 的值变为 true，即副作用函数的执行过期了。于是等请求 A 的结果返回时，其结果会被抛弃，从而避免了过期的副作用函数带来的影响，如图4-13所示。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fc391b6701624b18ae1cf6972a989f2f.jpeg#pic_center =x300)
<center>图4-13 请求过期</center>

### 12. 总结
首先介绍了副作用函数和响应式数据的概念，以及它们之间的关系。
响应系统的根本实现原理：一个响应式数据最基本的实现依赖于对“读取“和“设量“操作的拦截，从而在副作用函数与响应式数据之同建立联系。当“读取“操作发生时，我们将当前执行的刷作用函数存储到“桶”中；当“设置”操作发生时，再将副作用函数从“桶“里取出并执行。

实现一个相对完善的响应系统：使用 Meakap 配合MaP 构建了新的“桶”结构，从而能够在响应式数据与副作用函数之间建立更加糖确的联系。
WeakMap与Nep两个数据结构之间的区别：MeakMap 是弱引用的，它不影响垃圾回收器的工作。当用户代码对一个对象没有引用关系时，MeakMap 不会阻止垃圾回收器回收该对象。

分支切换导致的冗余副作用的问题：这个问题会导致副作用函数进行不必要的更新。为了解决这个问题，我们需要在每次副作用函数重新执行之前，清除上一次建立的响应联系，而当副作用函数重新执行后，会再次建立新的响应联系，新的响应联系中不存在冗余副作用问题，从而解决了问题。
遍历 set 数据结构导致无限循环的新问题：该问题产生的原因可以从 ECMA 规范中得知，即“在调用 forEach 遍历 Set 集合时，如果一个值已经被访问过了，但这个值被删除并重新添加到集合，如果此时 forEach 遍历没有结束，那么这个值会重新被访问。解决方案是建立一个新的 Set 数据结构用来遍历。

关于嵌套的副作用函数的问题：在实际场景中，嵌套的副作用函数发生在组件嵌套的场景中，即父子组件关系。这时为了避免在响应式数据与副作用函数之间建立的响应联系发生错乱，我们需要使用副作用函数栈来存储不同的副作用函数。当一个副作用函数执行完毕后，将其从栈中弹出。当读取响应式数据的时候，被读取的响应式数据只会与当前栈顶的副作用函数建立响应联系，从而解决问题。
副作用函数无限递归地调用自身，导致栈溢出的问题：该问题的根本原因在于，对响应式数据的读取和设置操作发生在同一个副作用函数内。解决办法很简单，如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行。

响应系统的可调度性：所谓可调度，指的是当 trigger 动作触发副作用函数重新执行时，有能力决定副作用函数执行的时机、次数以及方式。为了实现调度能力，我们为 effect 函数增加了第二个选项参数，可以通过 scheduler 选项指定调用器，这样用户可以通过调度器自行完成任务的调度。通过调度器实现任务去重：即通过一个微任务队列对任务进行缓存，从而实现去重。

计算属性（即 computed）：计算属性实际上是一个懒执行的副作用函数，我们通过 lazy 选项使得副作用函数可以懒执行。被标记为懒执行的副作用函数可以通过手动方式让其执行。利用这个特点，我们设计了计算属性，当读取计算属性的值时，只需要手动执行副作用函效即可。当计算属性依赖的响应式数据发生变化时，会通过 scheduler 将 dirty 标记设置为 true，代表“脏”。这样，下次读取计算属性的值时，我们会重新计算真正的值。

watch的实现原理：它本质上利用了副作用函数重新执行时的可调度性。一个 watch 本身会创建一个 effect，当这个 effect 依赖的响应式数据发生变化时，会执行该effect 的调度器函数，即scheduler。这里的 scheduler 可以理解“回调”，所以我们只需要在scheduler 中执行用户通过 watch 函数注册的回调函数即可。此外，立即执行回调的 watch，通过添加新的 inmediate 选项来实现。如何控制回调函数的执行时机，通过flush 选项来指定回调函数具体的执行时机，本质上是利用了调用器和异步的微任务队列。

过期的副作用函数：它会导致竞态问题。为了解决这个问题，Vue.js 为 watch 的回调函数设计了第三个参数，即 onInvalidate。它是一个函数，用来注册过期回调。每当watch的回调函数执行之前，会优先执行用户通过 onInvalidate 注册的过期回调。这样，用户就有机会在过期回调中将上一次的副作用标记为“过期”，从而解决竞态问题。




